<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="style.css">
  <script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.js"></script>
  <title>Le Grand Oral</title>
</head>
<body>
  <h1>Mon grand Oral</h1>
  <h2>Problématique :</h2>
  <h2>"L'algorithme racine carrée inverse rapide : doit-on privilégier les performances en dépit d'un mauvais code ?"</h2>
  <ul>
    <h3>Sommaire</h3>
    <!--INFOS :
      temps d'exécution : 3.54ns-->
    <li> <a href="#presentation">Présentation de l'algorithme</a></li>
    <li> <a href="#utilite">À quoi sert cet algorithme ?</a></li>
    <li><a href="#bibliographie">Bibliographie</a></li>
  </ul>
  <h3 id="presentation">Présentation</h3>
  <p>L'algorithme "fast inverse square root" est un algorithme créé par Greg Walsh, un développeur de la compagnie Ardent. 
    <br>
    Il se Repose sur les travaux de William Kahan ayant publié 10 ans avant montrant comment calculer une racine carrée en manipulant des bits et en utilisant la méthode de Newton.
    <br>
    L'algorithme a été repris par ses collègues dont un appelé Brian Hook qui l'a alors conservé et réutilisé dans son poste de développeur de jeux pour la compagnie Id Software, créateurs des jeux Doom et Quake.
    <br>
    Cet algorithme est alors devenu une icône dans le monde de l'optimisation lors de la publication Open Source du code du jeu Quake III, dans lequel il était utilisé.
</p>
  <h3>À quoi sert la racine carrée inverse ?</h3>
  <p>
  La racine carrée inverse est une fonction composée utilisée en géométrie, aussi bien dans l'espace que dans le plan.
    <br>
  Partons d'un vecteur \(\vec{v} = \pmatrix{x \\ y}\).
    <br>
  Nous voulons que la somme de ses coordonnées soit égale à 1.
    <br>
  Ce processus s'appelle la normalisation.
    <br>
  Pour obtenir \(\vec{w}\) ; représentant le résultat de la normalisation de \(\vec{v}\), nous devons diviser chaque valeur de \(\vec{v}\) par 
    <br>
  Soit \(\alpha\) la norme euclidienne de \(\vec{v}\) :
  $$\alpha = \sqrt{x_{\vec{v}}^2 + y_{\vec{v}}^2}$$
    <br>
    Ainsi, on peut calculer \(\vec{w}\) :
    $$\vec{w} = \pmatrix{\frac{x_\vec{v}}{\alpha}\\\frac{y_\vec{v}}{\alpha}}$$
    <br>
    Maintenant, notre vecteur est normalisé.
    <br>
    Voici une démonstration de La normalisation d'un vecteur (ici en 2 dimensions).
    Vous verrez aussi par la même occasion que l'algorithme présenté est fiable et n'a une marche d'erreur .

  
  </p>
  
  <pre>
    <code>
      float q_rsqrt(float number){
        long i;
        float x2, y;
        const float threehalfs = 1.5F;
        
        x2 = number * 0.5F;
        y  = number;
        i  = * ( long * ) &y;                       // evil floating point bit level hacking
        i  = 0x5f3759df - ( i >> 1 );               // what the f*ck?
        y  = * ( float * ) &i;
        y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration
        // y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed
        
        return y;
      }
    </code>
  </pre>
  <p>Tester le code</p>
  <p style="display:inline">Entrez une valeur :</p>
  <input type="text" placeholder="10.5" step=0.000001 id="q-sqrt-input">
  <button id="exec-q-sqrt">Exécuter</button>
  <div class="code-result-div" id="q-sqrt-result-div">
    <p class="code-result" id="q-sqrt-result">Résultat</p>
  </div>

  <div id="demo-grid">
    <div id="demo">
    </div>
    <div id="animation-steps">
    </div>
  </div>
  <button id="normalize-button">Normaliser le vecteur</button>

  <h3>Pourquoi utilise-t-on cet algorithme ?</h3>
  <p>Il est vrai que le code est très dur à comprendre.
    <br>
    Alors pourquoi n'utilise-t-on pas un algorithme plus simple, tel que celui-ci ?
    <pre>
      <code>
        #include &#60;math.h&#62;
        float inverse_sqrt(float number) {
          return 1 / sqrt(number);
        }
      </code>
    </pre>
    La réponse est qu'il est <strong>LENT</strong> car les opérations racine carrée et division sont toutes les deux compliquées à calculer.
    <br>
    Contrairement à la multiplication et aux opérations "bitwise" (au niveau de la représentation binaire) qui, elles, sont très rapides.
    <br>
    En moyenne, q_rsqrt est 3 à 4 fois plus rapide que inverse_sqrt en présentant une précision de plus de 99% avec une seule itération de la méthode de Newton;
    <!--gcc -Wall -save-temps fast_rsqrt.c -o fast_rsqrt -lm-->

  </p>

  <hr>
  <h3 id="bibliographie">Bibliographie</h3>
  <a href="https://www.beyond3d.com/content/articles/15/">Origin of Quake3's Fast InvSqrt()</a>
  <a href="https://fr.wikipedia.org/wiki/Racine_carr%C3%A9e_inverse_rapide">Racine carrée inversée - Wikipedia</a>
  <a href="https://www.geeksforgeeks.org/compiling-a-c-program-behind-the-scenes/">Compiling a C Program: Behind the Scenes (Geeks for Geeks)</a>
  <a href="https://www.youtube.com/watch?v=p8u_k2LIZyo">"Fast Inverse Square Root — A Quake III Algorithm" - Nemean (YouTube)</a>
  <a href="https://www.youtube.com/watch?v=tmb6bLbxd08">"The Truth about the Fast Inverse Square Root on the N64" - Kaze Emmanuar (YouTube)</a>
  <a href="https://www.youtube.com/watch?v=4LiP39gJuqE">"Optimizing with "Bad Code"" - Kaze Emmanuar (YouTube)</a>



  <script src="load.js"></script>
  <script type="module" src="main.js"></script>
  <script type="module" src="animation.js"></script>
</body>
</html>